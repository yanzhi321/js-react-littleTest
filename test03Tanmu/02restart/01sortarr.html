<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
</html>
<script>
	
	
	//冒牌排序
	//1思想：冒泡排序思想：每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置
	      // 要实现上述规则需要用到两层for循环，外层从第一个数到倒数第二个数，内层从外层的后面一个数到最后一个数
	//2特点：排序算法的基础。简单实用易于理解，缺点是比较次数多，效率较低。
	var arr=[33,88,2,10,44,0];
	
	var times=0;  
	var bubbleSort=function(arr){  
	    for(var i=0;i<arr.length-1;i++){  
	        for(var j=i+1;j<arr.length;j++){  
	            if(arr[i]>arr[j]){//如果前面的数据比后面的大就交换  
	                var temp=arr[i];  
	                arr[i]=arr[j];  
	                arr[j]=temp;  
	            }  
	        console.log("第"+(++times)+"次排序后："+arr);  
	        }  
	    }   
	    return arr;  
	}  
	console.log("The result is:"+bubbleSort(arr));
	
	//二：快速排序
	//1思想：快速排序思想：先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。
	//    左右分别用一个空数组去存储比较后的数据。最后递归执行上述操作，直到数组长度<=1;
	//2特点：快速，常用。缺点是需要另外声明两个数组，浪费了内存空间资源。
	var times=0;  
	var quickSort=function(arr){   
	    //如果数组长度小于等于1无需判断直接返回即可  
	    if(arr.length<=1){  
	        return arr;  
	    }  
	    var midIndex=Math.floor(arr.length/2);//取基准点  
	    var midIndexVal=arr.splice(midIndex,1);//取基准点的值,splice(index,1)函数可以返回数组中被删除的那个数arr[index+1]  
	    var left=[];//存放比基准点小的数组  
	    var right=[];//存放比基准点大的数组  
	    //遍历数组，进行判断分配  
	    for(var i=0;i<arr.length;i++){  
	        if(arr[i]<midIndexVal){  
	            left.push(arr[i]);//比基准点小的放在左边数组  
	        }  
	        else{  
	            right.push(arr[i]);//比基准点大的放在右边数组  
	        }  
	        console.log("第"+(++times)+"次排序后："+arr);  
	    }  
	    //递归执行以上操作,对左右两个数组进行操作，直到数组长度为<=1；  
	    return quickSort(left).concat(midIndexVal,quickSort(right));  
	};  
	console.log(quickSort(arr));  
	
	
	//伪代码
	/*【简单示例】输入3个数，打印输出其中最大的数。可用如下的伪代码表示：
	Begin
	输入 A，B，C
	IF A>B 则 A→Max
	否则 B→Max
	IF C>Max 则 C→Max
	Print Max
	End 。*/
	

	
</script>